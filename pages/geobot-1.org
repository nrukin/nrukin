#+title: Телеграм-бот на Go для геотрекинга. Часть 1
#+date: <2024-02-06>
#+keywords: draft

В жизни каждого программиста периодически возникает
желание напрограммировать какого-нибудь (/очередного/) бота.

Вот и я решил написать telegram-бота, идея появилась давно:
в telegram есть возможность делиться живой геопозицией, я хочу отправлять её боту,
а затем анализировать записанный ботом трек, как это делают
разные фитнес-трекеры, только без использования специальных программ и оборудования.

Делать бота я буду на Go.

Итак, поехали:

* Создание проекта. Простой бот
Создаем каталог проекта, инициализируем go-модуль
#+begin_src shell
  mkdir geotracker-bot && cd geotracker-bot
  go mod init github.com/nrukin/geotracker-bot
#+end_src

Cоздам простой файл =main.go= с содержимым:
#+begin_src go -n
  package main

  import (
	  "log"
	  "os"

	  tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
  )

  func main() {
	  if len(os.Args) < 2 {
		  log.Fatal("token not set")
	  }
	  token := os.Args[1]
	  bot, err := tgbotapi.NewBotAPI(token)
	  if err != nil {
		  log.Panic(err)
	  }
	  log.Printf("Authorised on account %s", bot.Self.UserName)
  }
#+end_src

В этом файле мы:
1. Импортируем библиотеку [[https://github.com/go-telegram-bot-api/telegram-bot-api][telegram-bot-api]]
2. Получаем токен телеграм бота из параметров командной строки
3. Пытаемся авторизоваться в телеграм по полученному токену

Для того чтобы проверить работу кода нужен токен бота, за этим надо обратиться к телеграм-боту [[https://t.me/BotFather][BotFather]]

Устанавливаем зависимости.
#+begin_src shell
  go mod tidy
#+end_src

Запускаем бота, конечно же, нужно заменить *=<TOKEN>=* на настоящий токен бота.
#+begin_src shell
  go run . <TOKEN>
#+end_src

Если всё прошло удачно - в консоли будет выведено что-то типа =Authorised on account MyAwesomeBot=

Уф, самая сложная часть позади, дальше будет легче.

* Продолжение: Получение позиции и треки
Нужно научиться получать координаты и что-то с ними делать. Поступать они могут
двумя способами:

+ При первой отправке приходит новое сообщение с координатами
+ Потом бот начинает присылать обновления первого сообщения с новыми координатами и временем

Нужно научиться читать входящие сообщения с обновлениями, и получать из них координаты.

У tgbotapi есть богатая [[https://pkg.go.dev/github.com/go-telegram-bot-api/telegram-bot-api/v5][документация]].

Приступим:

+ Для работы с геопозициями создадим новый тип =Location= с полями широты, долготы и времени позиции.
+ Напишем код разбирающий входящие сообщения и обновления, и вытаскивающий из них эту позицию
+ Добавим в =Location= свойство *=Track=*, для того чтобы распределить координаты по сообщениям
  + Идентификатором трека будет строка, состоящая из идентификатора чата и идентификатора сообщения в этом чате
  + Добавим функцию =*getTrackFromMessage*= для получения идентификатора трека

#+begin_src go -n
  package main

  import (
	  "errors"
	  "log"
	  "os"

	  tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
  )

  type Location struct {
	  Track     string
	  Latitude  float64
	  Longitude float64
	  Timestamp int
  }

  func main() {
	  if len(os.Args) < 2 {
		  log.Fatal("token not set")
	  }
	  token := os.Args[1]
	  bot, err := tgbotapi.NewBotAPI(token)
	  if err != nil {
		  log.Panic(err)
	  }
	  log.Printf("Authorised on account %s", bot.Self.UserName)

	  bot.Debug = true

	  u := tgbotapi.NewUpdate(0)
	  u.Timeout = 60

	  updates := bot.GetUpdatesChan(u)

	  for update := range updates {

		  var msg *tgbotapi.Message
		  switch {

		  case update.Message != nil:
			  msg = update.Message
		  case update.EditedMessage != nil:
			  msg = update.EditedMessage
		  default:
			  continue
		  }

		  loc, err := getLocationFromMessage(msg)
		  if err != nil {
			  log.Print(err)
			  continue
		  }
		  log.Printf("%+v", loc)

	  }
  }

  func getLocationFromMessage(msg *tgbotapi.Message) (Location, error) {

	  if msg.Location == nil {
		  return Location{}, errors.New("Msg has no location")
	  }

	  tid := getTrackFromMessage(msg)

	  loc := Location{
		  Track:     tid,
		  Latitude:  msg.Location.Latitude,
		  Longitude: msg.Location.Longitude,
		  Timestamp: msg.Date,
	  }

	  if msg.EditDate != 0 {
		  loc.Timestamp = msg.EditDate
	  }

	  return loc, nil

  }

  func getTrackFromMessage(msg *tgbotapi.Message) string {
	  return fmt.Sprintf("%d_%d", msg.Chat.ID, msg.MessageID)
  }
#+end_src

Запускаем бота, открываем в телефоне чат, делимся позицией,
смотрим как в консоли выводятся координаты. Красивое.

* База данных
#+begin_quote
Три вопроса меня волнуют:
1. Зачем писать запросы если можно использовать ORM
2. Зачем использовать ORM если можно писать запросы
3. Зачем жрать капусту если есть картошка[fn:1]
#+end_quote

Поисковик рекомендует [[https://gorm.io/][GORM]] как ORM для Go, кто я такой чтобы спорить с поисковиком?

В качестве базы данных будет sqlite3, потому что нормально.

Прочитаем документацию GORM и внесем правки:

#+begin_src go -n
  package main

  import (
	  "errors"
	  "fmt"
	  "log"
	  "os"

	  tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
	  "gorm.io/driver/sqlite"
	  "gorm.io/gorm"
  )

  type Location struct {
	  gorm.Model
	  Track     string
	  Latitude  float64
	  Longitude float64
	  Timestamp int
  }

  func main() {

	  if len(os.Args) < 2 {
		  log.Fatal("token not set")
	  }
	  token := os.Args[1]
	  bot, err := tgbotapi.NewBotAPI(token)
	  if err != nil {
		  log.Panic(err)
	  }
	  log.Printf("Authorised on account %s", bot.Self.UserName)

	  bot.Debug = true

	  dbFilename := "track.db"
	  db, err := gorm.Open(sqlite.Open(dbFilename), &gorm.Config{})
	  if err != nil {
		  log.Panic(err)
	  }

	  db.AutoMigrate(&Location{})

	  u := tgbotapi.NewUpdate(0)
	  u.Timeout = 60

	  updates := bot.GetUpdatesChan(u)

	  for update := range updates {

		  var msg *tgbotapi.Message
		  switch {

		  case update.Message != nil:
			  msg = update.Message
		  case update.EditedMessage != nil:
			  msg = update.EditedMessage
		  default:
			  continue
		  }

		  loc, err := getLocationFromMessage(msg)
		  if err != nil {
			  log.Print(err)
			  continue
		  }
		  log.Printf("%+v", loc)
		  db.Create(&loc)

	  }
  }

  func getLocationFromMessage(msg *tgbotapi.Message) (Location, error) {

	  if msg.Location == nil {
		  return Location{}, errors.New("Msg has no location")
	  }

	  tid := getTrackFromMessage(msg)

	  loc := Location{
		  Track:     tid,
		  Latitude:  msg.Location.Latitude,
		  Longitude: msg.Location.Longitude,
		  Timestamp: msg.Date,
	  }

	  if msg.EditDate != 0 {
		  loc.Timestamp = msg.EditDate
	  }

	  return loc, nil

  }

  func getTrackFromMessage(msg *tgbotapi.Message) string {
	  return fmt.Sprintf("%d_%d", msg.Chat.ID, msg.MessageID)
  }
#+end_src

Что изменилось:

1. Импортирован gorm
2. В модель =Location= добавлена модель из gorm - это необходимо для возможности сохранения и чтения из базы данных
3. При начале работы выполняется подключение к базе данных в файле =track.db=, выполняется миграция
4. После поступления координаты сохраняются в табличке базы данных

* Footnotes

[fn:1] https://youtu.be/muEEtWI2CKc 



