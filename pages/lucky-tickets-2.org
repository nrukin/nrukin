#+title: Подсчет счастливых билетов на Python
#+date: <2023-10-20>
#+keywords: draft

Яндекс.Метрика показывает несколько визитов предыдущего поста из по поисковым запросам "Счастливые билеты Python".

Мне кажется вы нашли немного не то что искали.
Ну чтож, я не то чтобы большой специалист по Python, но почему бы и не да?

Решать буду задачу: /Посчитать количество счастливых билетов в выборке 10^(2*n+1)-1 где n задается пользователем/.

Проще говоря - пользователь задает 3, значит берем бобину(хе) из 10^(2*3+1)-1=999999 билетов и находим сколько из них счастливых.
Напомню - счастливый билет это билет у которого сумма цифр в левой половине равна сумме цифр в правой половине.

Во-вторых: википедия говорит что для этой задачи есть формула, я сделаю вид что не знаю о её существовании, решать задачу
буду исключительно итеративно.

* Вариант 1. Примитивный
Самый простой алгоритм:

#+begin_src python
  import sys

  def countTickets(n):
      res = 0
      # В цикле перебираем все варианты в выборке
      for i in range(pow(10, 2 * n)):
	  # В каждой итерации цикла попробуем
	  # понять - является ли наш билетик счастливым или нет

	  # Преобразуем число в кортеж чисел
	  # для этого конвертируем число в строку с лидирующими
	  # нолями, а затем разложим строку на отдельные символы
	  # и конвертируем обратно
	  d = [int(q) for q in str(i).zfill(n*2)]

	  # при помощи срезов посчитаем суммы левой
	  # и правой половинок кортежа, и инкременритуем счетчик
	  # при совпадении
	  if sum(d[:n]) == sum(d[n:]):
	      res+=1

      return res

  if __name__ == "__main__":
      # Значение по-умолчанию
      n = 3
      # проверяем - если был передан параметр
      # командной строки - используем его
      if len(sys.argv) > 1:
	  n = int(sys.argv[1])

      res = countTickets(n)

      # Выведем результат. Используем f-string, они прикольные
      print(f'Найдено билетов: {res}')
#+end_src

В принципе в комментариях всё подробно расписано - из параметров командной строки передается параметр,
формируем цикл, преобразуем число в строку, разбиваем на символы, собираем обратно, считаем суммы левой и правой половин.

Выполним пару пробных запусков:
#+begin_src shell
  > python3 v01.py 1
  Найдено билетов: 10

  > python3 v01.py 2
  Найдено билетов: 670

  > python3 v01.py 3
  Найдено билетов: 55252

  > python3 v01.py
  Найдено билетов: 55252
#+end_src

Вроде похоже на правду.
Результаты последних двух одинаковы потому что 3 - значение по-умолчанию.

Параметры до трех отрабатывают почти мгновенно, четверка заставила ноут задуматься на три минуты,
пятерки я не дождался.

Здесь однозначно есть место для оптимизации алгоритма.

* Вариант 2. Многопоточно
Очевидно что у нас есть некоторый набор расчетов, каждый из которых не зависит от расчетов других,
значит мы смело можем разбить наш список на несколько раздельных списков и вычислить в несколько
параллельных потоков. Т.е., например, мы хотим посчитать билеты от 0 до 99: разобъем все 100 билетов
на 4 пачки:
+ 00-24
+ 24-49
+ 50-74
+ 75-99
И запустим четые параллельных расчета, а в конце отсуммируем результаты.
Расчет должен будет выполниться в четыре раза быстрее.

Запилим такой алгоритм:


Знания о многопоточке в питоне у меня поверхностные, я только читал про них у Лутца, но на практике
применять как-то не пришлось. Ладно, попробуем.

