#+title: Задача счастливых билетиков и сравнение производительности
#+date: <2023-09-21>
#+keywords: draft

Когда-то давно, когда я ещё учился в универе, на лекции по математике разбиралась
формула определения количества счастливых билетов. Под счастливым билетом подразумевается
билет с номером, в котором сумма трех левых цифр и сумма трех правых цифр равна.
Формула определяла количество вариантов удовлетворяющих условию в 999999 вариантов номеров билетов.

Приехав домой я захотел проверить формулу, поэтому я открыл 1с, и написал примерно такой код:
#+begin_src 
Результат = 0;
Для Счетчик = 0 По 999999 Цикл
    СчетчикСтрокой = Формат(Счетчик, "ЧЦ=6; ЧН=; ЧВН=; ЧГ=");
    СуммаЛев = Число(Сред(СчетчикСтрокой,1,1)) + Число(Сред(СчетчикСтрокой,2,1)) + Число(Сред(СчетчикСтрокой,3,1));
    СуммаПрав = Число(Сред(СчетчикСтрокой,4,1)) + Число(Сред(СчетчикСтрокой,5,1)) + Число(Сред(СчетчикСтрокой,6,1));

    Если СуммаЛев = СуммаПрав Тогда
        Сообщить(СчетчикСтрокой);
        Результат = Результат + 1;
    КонецЕсли;
КонецЦикла;

Сообщить("Количество: " + Результат);
#+end_src
Код выполнялся долго, очень долго, терпения дождаться у меня не хватило и в итоге я бросил не завершив.

Недавно я вспомнил об этой истории: задача простая, алгоритм примитивный, а реализацию реально можно использовать
для сравнения производительности, например, разных языков программирования. Что я и сделал:

* О тестовом стедне
Весь код запускается на одной и той же машине, в связи с тем что здесь у нас участвует 1С, я буду использовать
компьютер под управлением Windows на процессоре *AMD Ryzen 5 3500U*

* 1C
** Числа
В первую очередь я переписал алгоритм на 1С. На этот раз я отказался от строковых конвертаций и от
вывода результатов, что значительно ускорило выполнение.
#+begin_src 
&НаКлиенте
Процедура Команда1(Команда)
	Н = ТекущаяУниверсальнаяДатаВМиллисекундах();
	Р = 0;
	Для i = 0 По 999999 Цикл
		Если Цел(i/100000)%10 + Цел(i/10000)%10 + Цел(i/1000)%10 = Цел(i/100)%10 + Цел(i/10)%10 + Цел(i/1)%10 Тогда Р=Р+1; КонецЕсли;	
	КонецЦикла;
	К = ТекущаяУниверсальнаяДатаВМиллисекундах();
	Сообщить(СтрШаблон("Найдено: %1; Время выполнения: %2 с", Р, (К-Н)/1000));
КонецПроцедуры
#+end_src

Результаты трех запусков
#+begin_example
Найдено: 55 252; Время выполнения: 6,493 с
Найдено: 55 252; Время выполнения: 7,346 с
Найдено: 55 252; Время выполнения: 7,316 с
#+end_example

** Строки
Воспроизведу первый алгоритм, без избыточных сообщений:
#+begin_src 
&НаКлиенте
Процедура Команда2(Команда)
	
	Н = ТекущаяУниверсальнаяДатаВМиллисекундах();
	Р = 0;
	Для i = 0 По 999999 Цикл
		ст = Формат(i, "ЧЦ=6; ЧН=; ЧВН=; ЧГ=");
		Если Число(Сред(ст,1,1)) + Число(Сред(ст,2,1)) + Число(Сред(ст,3,1)) = Число(Сред(ст,4,1)) + Число(Сред(ст,5,1)) + Число(Сред(ст,6,1)) Тогда Р=Р+1; КонецЕсли;	
	КонецЦикла;
	К = ТекущаяУниверсальнаяДатаВМиллисекундах();
	Сообщить(СтрШаблон("Найдено: %1; Время выполнения: %2 с", Р, (К-Н)/1000));
	
КонецПроцедуры
#+end_src
И снова три запуска:

#+begin_example
Найдено: 55 252; Время выполнения: 15,712 с
Найдено: 55 252; Время выполнения: 15,557 с
Найдено: 55 252; Время выполнения: 16,121 с
#+end_example

* Python
** Прямой алгоритм
Напишу такой же алгоритм, но уже на Python3.
#+begin_src python
  from math import floor
  from time import time
  r = 0
  s = time()
  for i in range(1000000):
      if floor(i/100000)%10 + floor(i/10000)%10 + floor(i/1000)%10 == floor(i/100)%10 + floor(i/10)%10 + floor(i/1)%10:
	  r+=1
  e = time()
  print('found: {}; time: {}'.format(r, (e-s)))
#+end_src

Смысл кода не меняется, для замера времени используется явный вызов функции =time= из пакета =time=, что, наверное, не до
конца правильно - в стандартной библиотеке есть более специализированные средства для задачи замеров времени выполнения кода,
но я осознанно оставил time для единообразия алгоритма на всех языках.

Итак, результаты запуска:
#+begin_example
found: 55252; time: 1.3160340785980225
found: 55252; time: 1.1410844326019287
found: 55252; time: 1.1812174320220947
#+end_example

В некоторых случаях результаты были чуть меньше секунды, в районе 0.9, но оставлю то что дали три последних.

** Генератор
Вторая реализация не несет ничего нового, просто использует генераторы списков вместо итераций:

#+begin_src python
  from math import floor
  from time import time

  s = time()
  r = len([i for i in range(1000000) if floor(i/100000)%10 + floor(i/10000)%10 + floor(i/1000)%10 == floor(i/100)%10 + floor(i/10)%10 + floor(i/1)%10])
  e = time()
  print('found: {}; time: {}'.format(r, (e-s)))
#+end_src

Результаты немного меньше варианта с итерациями.
#+begin_example
found: 55252; time: 1.0612552165985107
found: 55252; time: 0.9660782814025879
found: 55252; time: 0.9880800247192383
#+end_example

* Golang

#+begin_src go
  package main

  import (
	  "fmt"
	  "math"
	  "time"
  )

  func main() {
	  s := time.Now()
	  r := 0
	  for i := 0.0; i <= 999999.0; i++ {

		  if int(math.Floor(i/100000.))%10+
			  int(math.Floor(i/10000.))%10+
			  int(math.Floor(i/1000.))%10 ==
			  int(math.Floor(i/100.))%10+
				  int(math.Floor(i/10.))%10+
				  int(math.Floor(i/1.))%10 {
			  r++
		  }

	  }
	  e := time.Now()
	  fmt.Printf("found: %d; time: %v", r, e.Sub(s))
  }
#+end_src

#+begin_example
  found: 55252; time: 30.6257ms
  found: 55252; time: 26.9537ms
  found: 55252; time: 34.6804ms
#+end_example

* Elisp

#+begin_src emacs-lisp
  (defun lucky-numbers ()
    (interactive)
    "Считаем счастливые номера билетов от 000000 до 999999, замеряем время выполнения"
    (let ((num 0)
	  (res 0)
	  (start-time (current-time)))
      (while (<= num 999999)
	(when 
	    (= (+ (% (floor (/ num 100000)) 10)
		  (% (floor (/ num 10000)) 10)
		  (% (floor (/ num 1000)) 10))
	       (+ (% (floor (/ num 100)) 10)
		  (% (floor (/ num 10)) 10)
		  (% (floor (/ num 1)) 10)))
	  (setq res (1+ res)))
	(setq num (1+ num)))
      (message "found %s; time %.3fs"
	       res (float-time (time-subtract (current-time) start-time)))))

  (progn 
    (lucky-numbers)
    (lucky-numbers)
    (lucky-numbers))
#+end_src

#+begin_example
  found 55252; time 2.181s
  found 55252; time 2.403s
  found 55252; time 2.052s
#+end_example

* Итоги
| Язык   | Алгоритм  | Время выполнения, с |
|--------+-----------+---------------------|
| 1С     | Числа     |               6,493 |
| 1С     | Строки    |              15,557 |
| Python | Итерации  |               1.141 |
| Python | Генератор |               0.966 |
| Go     |           |               0.027 |
| Elisp  |           |               2.052 |
