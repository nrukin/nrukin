#+title: Задача счастливых билетиков и сравнение производительности языков
#+date: <2023-09-21>
#+keywords: benchmark

Когда-то давно, когда я ещё учился в универе, на лекции по математике разбиралась
формула определения количества счастливых билетов. Под счастливым билетом подразумевается
билет с номером, в котором сумма трех левых цифр и сумма трех правых цифр равна.
Формула определяла количество вариантов удовлетворяющих условию в 999999 вариантов номеров билетов.

Приехав домой я захотел проверить расчет: открыл 1с и написал примерно такой код:
#+begin_src 
Результат = 0;
Для Счетчик = 0 По 999999 Цикл
    СчетчикСтрокой = Формат(Счетчик, "ЧЦ=6; ЧН=; ЧВН=; ЧГ=");
    СуммаЛев = 
        Число(Сред(СчетчикСтрокой,1,1)) + 
        Число(Сред(СчетчикСтрокой,2,1)) + 
        Число(Сред(СчетчикСтрокой,3,1));

    СуммаПрав = 
        Число(Сред(СчетчикСтрокой,4,1)) + 
        Число(Сред(СчетчикСтрокой,5,1)) + 
        Число(Сред(СчетчикСтрокой,6,1));

    Если СуммаЛев = СуммаПрав Тогда
        Сообщить(СчетчикСтрокой);
        Результат = Результат + 1;
    КонецЕсли;
КонецЦикла;

Сообщить("Количество: " + Результат);
#+end_src
Код выполнялся долго, очень долго, терпения дождаться у меня не хватило и в итоге я бросил не завершив.

Недавно я вспомнил об этой истории: задача простая, алгоритм примитивный, а реализацию реально можно использовать
для сравнения производительности, например, разных языков программирования. Что я и сделал:

* О тестовой машине
Весь код запускается на одной и той же машине, в связи с тем что здесь у нас участвует 1С, я буду использовать
компьютер под управлением Windows на процессоре *AMD Ryzen 5 3500U*. Понятно что один и тот же тест будет 
возвращать немного разные значения в зависимости от состояния машины, параллельных процессов и т.п.
,поэтому все результаты несут чисто приблизительный результат, и оценивать можно только порядок чисел.
* 1C
** Числа
В первую очередь я переписал алгоритм на 1С. На этот раз я отказался от строковых конвертаций и от
вывода результатов, что значительно ускорило выполнение.
#+begin_src 
&НаКлиенте
Процедура Команда1(Команда)
    Н = ТекущаяУниверсальнаяДатаВМиллисекундах();
    Р = 0;
    Для i = 0 По 999999 Цикл
        Если 
                Цел(i/100000)%10 + 
                Цел(i/10000)%10 + 
                Цел(i/1000)%10 = 
                Цел(i/100)%10 + 
                Цел(i/10)%10 + 
                Цел(i/1)%10 Тогда 
            Р=Р+1;
        КонецЕсли;
    КонецЦикла;
    К = ТекущаяУниверсальнаяДатаВМиллисекундах();
    Сообщить(СтрШаблон("Найдено: %1; Время выполнения: %2 с", Р, (К-Н)/1000));
КонецПроцедуры
#+end_src

Результаты трех запусков
#+begin_example
Найдено: 55 252; Время выполнения: 6,493 с
Найдено: 55 252; Время выполнения: 7,346 с
Найдено: 55 252; Время выполнения: 7,316 с
#+end_example

** Строки
Воспроизведу первый алгоритм, но без избыточных сообщений:
#+begin_src 
&НаКлиенте
Процедура Команда2(Команда)
    
    Н = ТекущаяУниверсальнаяДатаВМиллисекундах();
    Р = 0;
    Для i = 0 По 999999 Цикл
        ст = Формат(i, "ЧЦ=6; ЧН=; ЧВН=; ЧГ=");
        Если 
                Число(Сред(ст,1,1)) + 
                Число(Сред(ст,2,1)) + 
                Число(Сред(ст,3,1)) = 
                Число(Сред(ст,4,1)) + 
                Число(Сред(ст,5,1)) + 
                Число(Сред(ст,6,1)) Тогда 
            Р=Р+1; 
        КонецЕсли;    
    КонецЦикла;
    К = ТекущаяУниверсальнаяДатаВМиллисекундах();
    Сообщить(СтрШаблон("Найдено: %1; Время выполнения: %2 с", Р, (К-Н)/1000));
    
КонецПроцедуры
#+end_src
И снова три запуска:

#+begin_example
Найдено: 55 252; Время выполнения: 15,712 с
Найдено: 55 252; Время выполнения: 15,557 с
Найдено: 55 252; Время выполнения: 16,121 с
#+end_example

* Python
** Прямой алгоритм
Напишу такой же алгоритм, но уже на Python3.
#+begin_src python
  from math import floor
  from time import time
  r = 0
  s = time()
  for i in range(1000000):
      if floor(i/100000)%10 + \
	 floor(i/10000)%10 + \
	 floor(i/1000)%10 == \
	 floor(i/100)%10 + \
	 floor(i/10)%10 + \
	 floor(i/1)%10:
	  r+=1
  e = time()
  print('found: {}; time: {}'.format(r, (e-s)))
#+end_src

Смысл кода не меняется, для замера времени используется явный вызов функции =time= из пакета =time=, что, наверное, не до
конца правильно - в стандартной библиотеке есть более специализированные средства для задачи замеров времени выполнения кода,
но я осознанно оставил time для единообразия алгоритма на всех языках.

Итак, результаты запуска:
#+begin_example
found: 55252; time: 1.3160340785980225
found: 55252; time: 1.1410844326019287
found: 55252; time: 1.1812174320220947
#+end_example

В некоторых случаях результаты были чуть меньше секунды, в районе 0.9, но оставлю то что дали три последних.

** Генератор
Вторая реализация не несет ничего нового, просто использует генераторы списков вместо итераций:

#+begin_src python
  from math import floor
  from time import time

  s = time()
  r = len([i for i in range(1000000) if \
	   floor(i/100000)%10 + \
	   floor(i/10000)%10 + \
	   floor(i/1000)%10 == \
	   floor(i/100)%10 + \
	   floor(i/10)%10 + \
	   floor(i/1)%10])
  e = time()
  print('found: {}; time: {}'.format(r, (e-s)))
#+end_src

Результаты немного меньше варианта с итерациями.
#+begin_example
found: 55252; time: 1.0612552165985107
found: 55252; time: 0.9660782814025879
found: 55252; time: 0.9880800247192383
#+end_example

* Go

Перепишу алгоритм уже на Go.
Так как используется метод Floor библиотеки math, который раборает с float64 значением, 
инициирую переменную i типом float64, и добавлю несколько явных приведений типов.

#+begin_src go
  package main

  import (
	  "fmt"
	  "math"
	  "time"
  )

  func main() {
	  s := time.Now()
	  r := 0
	  for i := 0.0; i <= 999999.0; i++ {

		  if int(math.Floor(i/100000.))%10+
			  int(math.Floor(i/10000.))%10+
			  int(math.Floor(i/1000.))%10 ==
			  int(math.Floor(i/100.))%10+
				  int(math.Floor(i/10.))%10+
				  int(math.Floor(i/1.))%10 {
			  r++
		  }

	  }
	  e := time.Now()
	  fmt.Printf("found: %d; time: %v", r, e.Sub(s))
  }
#+end_src

Даже без использования каких-то оптимизаций и горутин результат весьма неплох.

#+begin_example
  found: 55252; time: 30.6257ms
  found: 55252; time: 26.9537ms
  found: 55252; time: 34.6804ms
#+end_example

* Elisp

Ну и как же без emacs lisp-а, перепишу процедуру на нем.

Открываю в emacs буфер =/*scratch/*=, пишу код, и затем последовательно выполняю
обе операции по =C-x e=.

#+begin_src emacs-lisp
  (defun lucky-numbers ()
    (interactive)
    "Считаем счастливые номера билетов от 000000 до 999999, 
  замеряем время выполнения"
    (let ((num 0)
	  (res 0)
	  (start-time (current-time)))
      (while (<= num 999999)
	(when 
	    (= (+ (% (floor (/ num 100000)) 10)
		  (% (floor (/ num 10000)) 10)
		  (% (floor (/ num 1000)) 10))
	       (+ (% (floor (/ num 100)) 10)
		  (% (floor (/ num 10)) 10)
		  (% (floor (/ num 1)) 10)))
	  (setq res (1+ res)))
	(setq num (1+ num)))
      (message "found %s; time %.3fs"
	       res (float-time (time-subtract (current-time) start-time)))))

  (progn 
    (lucky-numbers)
    (lucky-numbers)
    (lucky-numbers))
#+end_src

Результаты из буфера =/*Messages/*=:
#+begin_example
  found 55252; time 2.181s
  found 55252; time 2.403s
  found 55252; time 2.052s
#+end_example

* Итоги и выводы
Для каждого замера я взял самый быстрый показатель:
| Язык   | Алгоритм  | Время выполнения, с |
|--------+-----------+---------------------|
| 1С     | Числа     |               6,493 |
| 1С     | Строки    |              15,557 |
| Python | Итерации  |               1.141 |
| Python | Генератор |               0.966 |
| Go     |           |               0.027 |
| Elisp  |           |               2.052 |
Разница между Go и Python составляет почти 30 раз, что впечатляет.
Выводов не будет, потому что лень.
